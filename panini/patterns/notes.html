<html>

<head>
    <title>Potential concurrency and applicability constraints</title>
    <style>
    .code {font-family:Courier, monospaced;
}
    </style>
</head>


<body>
<h1>
Potential concurrency and applicability constraints
</h1>
<h2>
Note on generated code
</h2>
Autogenerated code is used in three ways.
<ul>
<li><em>Asynchronous wrappers</em>:  Given an instance X of a class implemementing an interface I, 
replace X an with instance of
a class that implements I and delegates to X in such a way that methods of I
can execute asynchronously.  In order to do so, return values are replaced with
transparent future proxies or "ducks",
as described below.  There are two execution models; methods may execute on a 
shared thread pool, and hence may execute in parallel, or are queued for execution in FIFO order by a single execution thread.
The shared model is used for Abstract Factory, Command, and Observer; the serial model
is used for Adapter, Facade, Proxy, Strategy, and Template method.
<li><em>Transparent future proxies</em>:  In order to implement an asynchronous wrapper, a method that
returns a value has to immediately return a proxy for the returned object in order to
allow the caller to continue execution concurrently with the creation of the return
value.  In cases where the return type is an interface, we generate a type that 
implements the same interface but actually encapsulates a Future for the actual result.
To the caller, the transparent future proxy is effectively indistinguishable from the actual result, 
but invocation of
its methods will block if the actual result has not yet been produced.  In the discussion below,
transparent future proxies are referred to as <em>ducks</em> ("if it walks like a duck..."). 
<li><em>Asynchronous subtypes</em>:  Given an instance X of a class, replace X with
a subtype of X in which specially annotated methods are made asynchronous.  This approach
is used for the Factory Method and Decorator patterns.

</ul>
<h2>
Summary
</h2>
<table border=2 cellspacing=3 cellpadding=3 >
<!--
<span class="code"></span>
-->

 <tr>
  <td><b>Pattern<b/></td>
  <td><b>Generated code<b/></td>
  <td><b>Annotations<b/></td>
  <td><b>Potential concurency</b>
  <td><b>Constraints<b/></td>
 </tr>

 <tr>
  <td>Abstract factory</td>
  <td>Async wrapper with parallel execution; returned products are ducks, provided that product is defined as an iterface.</td>
  <td><span class="code">@AbstractFactory</span> (1)</td>
  <td>
  If product creation is expensive AND main thread has other work to do between creation and use of product, product creation 
  can overlap with other work.  Multiple products can be created in parallel.
  </td>
  <td>
  Factory class itself is assumed to be stateless or effectively immutable.  Arguments passed in to factory
  methods must not be shared unless all access is read-only.
  </td>
 </tr>

 <tr>
  <td>Builder</td>
  <td>Async wrapper with serial execution.  Returned product is a duck, provided it is defined by an interface.</td>
  <td><span class="code">@Builder</span> (1)</td>
  <td>
  If steps involved in building product are expensive AND main thread has other work to do between creation and use 
  of product, building steps can overlap with other work.  Individual steps are serialized onto a single execution thread,
  not executed in parallel.  However, you can get task parallelism by creating multiple builders (as is 
  done in the automated grader example).
  </td>
  <td>
  See Note (3). In addition, arguments to the builder class methods must not be shared 
  unless all access is read-only.
  </td>
 </tr>

 <tr>
  <td>Factory method</td>
  <td>Creates a subtype of the given class in which annotated methods are executed asynchronouly.  Methods
  must return an interface, for which a duck is generated.</td>
  <td><span class="code">@FactoryMethod</span></td>
  <td>
  If product creation is expensive AND main thread has other work to do between creation and use of product, product creation 
  can overlap with other work.  Multiple products can be created in parallel.
  </td>
  <td>
  Enclosing class is assumed to be stateless or effectively immutable.  Arguments passed in to factory
  methods must not be shared unless all access is read-only.
  </td>
 </tr>

 <tr>
  <td>Prototype</td>
  <td>None</td>
  <td>None</td>
  <td>
  If creation of clone is expensive AND main thread has other work do to between creation and use of clone,
  clone creation can overlap with other work.  Multiple clones can be created in parallel.
  </td>
  <td>
  Clone creation is assumed NOT to modify state of original.
  </td>
  </tr>

 <tr>
  <td>Singleton</td>
  <td>X</td>
  <td>X</td>
  <td>X</td>
  <td>X</td>
 </tr>

  <tr>
  <td>Adapter</td>
  <td>Async wrapper with serial execution.  Ducks are generated for any return value that is an
   interface. </td>
  <td><span class="code">@Adapter</span> (1)</td>
  <td>
  If methods on Adaptor are expensive AND main thread has other work do, Adaptor method
  can overlap with other work.  Multiple calls are serialized onto single-threaded executor.
  </td>
  <td>
  See Note (3).  In addition, arguments to Adaptor methods must not be shared 
  unless all access is read-only.
  </td>
 </tr>

  <tr>
  <td>Bridge</td>
  <td>X</td>
  <td>X</td>
  <td>X</td>
  <td>X</td>
 </tr>

 <tr>
  <td>Composite</td>
  <td>None; components extend abstract class <span class="code">ConcurrentComposite</span> or
       <span class="code">ConcurrentLeaf</span>.</td>
  <td>None</td>
  <td>
  Traversal of composite structure can be performed concurrently (recursive decomposition using fork-join framework).
  </td>
  <td>
  Action or result at any node depends only on child nodes. Client is responsible for correctly overriding split() method to avoid sharing operation arguments between tasks.
  </td>
 </tr>

 <tr>
  <td>Decorator</td>
  <td>Creates a subtype of given class in which "added behavior" methods are executed
  asynchronously.</td>
  <td><span class="code">@Decorator</span>, <span class="code">@AddedBehavior</span></td>
  <td>
  If added-behavior operations include some expensive computation that does NOT modify component state,
  then it is possible for these computations to start before the final component is assembled.
  </td>
  <td>
  Very brittle; clients must follow precise organization of code as in example.
  </td>
 </tr>

 <tr>
  <td>Facade</td>
  <td>Async wrapper with serial execution.  Ducks are generated for any return value that is an
   interface. </td>
  <td><span class="code">@Facade</span> (1)</td>
  <td>
  If methods on Facade are expensive AND main thread has other work do, Facade method execution
  can overlap with other work.  Multiple calls are serialized onto single-threaded executor.
  </td>
  <td>
  See Note (3). In addition, arguments to Facade methods must not be shared 
  unless all access is read-only.
  </td>
 </tr>

 <tr>
  <td>Flyweight</td>
  <td>X</td>
  <td>X</td>
  <td>X</td>
  <td>X</td>
 </tr>
 
 <tr>
  <td>Proxy</td>
  <td>Async wrapper with serial execution.  Ducks are generated for any return value that is an
   interface. </td>
  <td><span class="code">@Proxy</span> (1)</td>
  <td>
  If methods on Proxy are expensive AND main thread has other work do, Proxy method execution
  can overlap with other work.  Multiple calls are serialized onto single-threaded executor.
  </td>
  <td>
  See Note (3).  In addition, arguments to Proxy methods must not be shared 
  unless all access is read-only.
  </td>
 </tr>

 <tr>
  <td>Proxy (creational)</td>
  <td>None (2)</td>
  <td><span class="code">@CreationalProxy</span>,
      <span class="code">@ProxyDelegate</span></td>
  <td>
  If object creation is expensive AND main thread has other work to do, creation can overlap
  with other work.  Differs from the general proxy pattern in that certain methods can be
  designated as not requiring the actual object to be created.
  </td>
  <td>
  Arguments to methods that trigger creation must not be shared 
  unless all access is read-only.  Client must take care not to create multiple instances.
  </td>
  </tr>
 
 <tr>
  <td>Chain of Responsibility</td>
  <td>None; handlers extend abstract class <span class="code">CORHandler</span>.</td>
  <td>None</td>
  <td>
  Calls to <span class="code">canHandle()</span> for multiple handlers can execute in parallel.
  </td>
  <td>
  All access to arguments passed to <span class="code">canHandle()</span>, if any, must be read-only.
  The <span class="code">canHandle()</span> methods themselves must be side-effect free.
  </td>
 </tr>

 <tr>
  <td>Command</td>
  <td>A <span class="code">CommandMaker</span> object.  A class is also created for an async wrapper
  for the command interface (the command object) and ducks for any of its methods that return an interface.
  The assumption is that for this pattern, async command objects will be created frequently,
  so the maker serves as a factory for generating new instances efficiently.
  </td>
  <td><span class="code">@Command</span> (1)</td>
  <td>
  Methods on an async command object execute in a shared thread pool.  If main thread does not
  need a result, or has other work to do, execution can occur in parallel.  Multiple command
  objects can run in parallel.  This is one way to get task parallelism.
  </td>
  <td>
  Command objects are assumed to be stateless or effectively immutable.  Arguments to command objects
  must not be shared unless all access is read-only.
  </td>
 </tr>

 <tr>
  <td>Interpreter</td>
  <td>None</td>
  <td>None</td>
  <td>Ad hoc (see examples)</td>
  <td></td>
 </tr>

 <tr>
  <td>Iterator</td>
  <td>None; clients use one of the forms of <span class="code">ConcurrentIterator.apply()</span>.</td>
  <td>None</td>
  <td>This is essentially a parallel for-loop over a collection, with map and reduce.  A client provides an 
  operation and a combiner.  The operation is performed on each element of the collection using a shared
  thread pool and temporarily saves the result of each operation; then the combiner is executed sequentially 
  on the results.  In an alternate form, a non-value-returning procedure is applied to each element
  of the collection.  
  <td>
  Potential difficulties abound. In general the assumptions have to be that
  <ol>
  <li>there is no data shared, directly or indirectly, between any elements of the collection,
  <li>all data in the collection is fully encapsulated (no references into it from outside the collection), and
  <li>no mutable data is referred to by elements of the collection, and
  <li>correctness is independent of ordering of elements in the collection.
  </ol>
  We also require that the Operation or Procedure and the Combiner are stateless or effectively immutable.
  </td>
 </tr>
 
 <tr>
  <td>Mediator</td>
  <td>None</td>
  <td>None</td>
  <td>This example is broken.</td>
  <td></td>
 </tr>

 <tr>
  <td>Memento</td>
  <td>X</td>
  <td>X</td>
  <td>X</td>
  <td>X</td>
 </tr>

 <tr>
  <td>Observer</td>
  <td>None; listeners extend abstract class <span class="code">ConcurrentObserver</span>.</td>
  <td>None</td>
  <td>Observers execute concurrently using shared thread pool.  Multiple observers can execute in
  parallel.  Another option for task parallelism.</td>
  <td>See Note (6). Each observer has a context passed to it. The client is responsible for making a deep copy 
  of the context for each observer, or else all access to context has to be read-only.
  Observers themselves are assumed not to share state with the 
  subject or with each other.</td>
 </tr>

 <tr>
  <td>Observer (simplified form using async wrapper)</td>
  <td>Async wrapper with parallel execution.</td>
  <td><span class="code">@Observer</span> (1)</td>
  <td>Same potential benefits as previous version of Observer.  (Note, the effect of the latching version
  can be acheived by giving each notify() method an interface return type and blocking on it.)   </td>
  <td>Same as above.</td>
 </tr>


 <tr>
  <td>State</td>
  <td>X</td>
  <td>X</td>
  <td>X</td>
  <td>X</td>
 </tr>

  <tr>
  <td>Strategy</td>
  <td>Async wrapper with parallel execution, along with ducks for methods that return an interface.</td>
  <td><span class="code">@Strategy</span> (1)</td>
  <td>
  If strategy methods are expensive AND main thread has other work to do, execution of strategy method
  and other work can overlap.  Multiple calls to strategy object methods can execute in parallel.  
  Can also use multiple strategy objects for task parallelism (as in the file-compression example).
  </td>
  <td>
  Strategy object is assumed to be stateless or effectively immutable.  (This might not be realistic, it might
  be better for strategy to use a single execution thread.)  In addition, arguments to Strategy object
  methods must not be shared 
  unless all access is read-only.
  </td>
 </tr>

 <tr>
  <td>Visitor</td>
  <td>None; visitors extend class <span class="code">AbstractConcurrentVisitor</span>,
      nodes implement interface <span class="code">VisitableNode</span>.</td>
  <td>None</td>
  <td>
  Traversal of list or tree structure can be performed concurrently (recursive decomposition using fork-join framework).
  </td>
  <td>
  Sibling nodes must be independent of each other.  If visitor has state, client is responsible for
  correctly overriding the copy() method to avoid sharing data.
  </td>
 </tr>

 <tr>
  <td>Template method</td>
  <td>Async wrapper with serial execution.  Ducks are generated for any return value that is an
   interface. </td>
  <td><span class="code">@Template</span> (1)</td>
  <td>
  If template method is expensive AND main thread has other work do, method execution
  can overlap with other work.  Multiple calls are serialized onto single-threaded executor.
  </td>
  <td>
  See Notes (3) and (4).  In addition, arguments to Template method must not be shared 
  unless all access is read-only.
  </td>
 </tr>


</table>
<ul style="list-style:none;">
<li>
(1) Annotations required for compile-time code generation. If annotation is omitted, code will be generated, compiled, and loaded at runtime.

<li>
(2) The asynchronous proxy object is currently implemented experimentally using <span class="code">java.lang.reflect.Proxy</span>.  There is 
no autogenerated code.
<li>
(3) 
For the serial forms of the async wrappers, we have to ensure that ALL method calls on the class are executed by the single
execution thread, whether or not they participate in the pattern.  This effectively
means that there are no methods other than those defined in the interface from which
we create the async wrapper, or else that the caller must take care not to call
any non-interface methods while execution an interface method is still pending.
(This problem does not arise with the parallel version of the async wrappers
because the enclosed class is assumed to be stateless to begin with.)

<p>
This applies to
Adapter,
Builder,
Facade,
Proxy,
Template method.

<p>

<li>
(4)
In the ideal setting there is an abstract class with just one
public method templateMethod() that may call various concrete or
abstract protected methods. So in theory it is only for the implementation
of templateMethod() that we need to create a task and return a
duck, since the execution has to be single threaded.  
<p>
However there may be other public methods, and it is important that all
public methods are executed by the same single-threaded executor.  So maybe
we do need to end up creating and enqueue-ing a task for all method calls?
<p>
For template method, rather than requiring an interface as with the other async proxy-
based patterns,  a better design might be to pass in the abstract class and 
the particular concrete subclass, and return a new subtype of the abstract class.

<li>
(5) Remember also: We are assuming throughout that the client is single-threaded to start with.
If the client is already creating multiple threads, <em>all bets are off</em>.

<li>
(6) GoF describes two possible implementations of the Observer pattern, referred to as the 
"push" model and the "pull" model.  In the latter, the Subject notifies Observers with the
information that its state has changed; Observers then call back into the Subject for 
details about the changed state.  In the former, the notification from the Subject includes
all information about the changed state, and there are no calls from Observer to Subject.
<em>The patterns framework supports only the "push" model.</em>

</ul>

</body>
</html>